------静态-------
1.const 常数据成员、常成员函数

2.静态数据成员和静态成员函数
如何定义？
class Tank
{
public:
   Tank()  {s_iCount++;}
   ~Tank() {s_iCount--;}
   static int getCount(){return s_iCount;}
   static int s_iCount;//坦克数量
//做为静态数据成员来说，它并不依赖与对象，而是依赖与类。如果我们不实例化对象，
//那么做为静态的数据成员s_iCount仍然在内存当中存在，这是与普通数据成员的最大区别。
//如果是普通的数据成员，则必须要实例化之后，这个数据成员才能存在；
//那么对于静态数据成员来说，因为它并不依赖于对象的示例化，所以静态的数据成员并不会在构造函数当中，
实例化。
private:
   string m_strCode;
};
int Tank::s_iCount=0;//就像这单独进行实例化
int main()
{
访问方法有两种：一种不通过对象而直接通过类的访问方法
   cout<<Tank::getCount()<<endl;
   cout<<Tank::s_iCount<<endl;
   Tank tank;
第二种：如果我们定义了对象，就可以通过对象点号的方式来调用静态成员函数和静态数据成员
   cout<<tank.getCount()<<endl;
   cout<<tank.s_iCount<<endl;
   return 0;
}

3.从this指针谈静态成员函数
class Tank
{
public:
   void fire();
   static int getCount();
private:
   string m_strCode;
   static int s_iCount;
};
//当我们通过fire调用普通的数据成员,和静态数据成员，看上去一个参数都不传，实际上传了隐形的this指针；

void fire(Tank *this)
{
   this->m_strCode="01";
   s_iCount=0;//它并不与对象相关而是与类相关，换句话说它是全局变量，在前面没有this也没事，直接修改
他的值，或直接调用相应的静态成员函数。
}
//反之如果我们使用的是静态的成员函数，那么做为静态的成员函数，它并不会传入隐形的this指针，
static int getCount()
{
    m_strCode="01";//这个时候你怎么知道你所调用的数据成员，究竟是哪一个对象的数据成员？
                     所以在静态的成员函数当中，无法调用非静态的数据成员或者是成员函数。
    return s_iCount;//但是我们可以在静态成员函数去调用静态的数据成员，由于静态的成员函数可以看作是
                       全局函数，而静态的数据成员也是一个全局的数据，所以如果通过静态的成员函数去调
                      用一个静态的成员没有问题，而调用一个非静态的数据成员就会因为this指针找不到，
                      无法确定它是哪个对象的数据成员，而造成编译是错误的。                    
}


4.注意事项
4.1静态数据成员必须单独初始化，写在类的外边初始化；因为它不随对象的产生而产生，随着类的产生而产生；
4.2静态成员函数不能调用非静态成员函数和非静态数据成员；反之如果是一个非静态的成员函数则可以调用静态
   的数据成员和静态的数据成员函数。
4.3静态数据成员只有一份，且不依赖对象而存在；

